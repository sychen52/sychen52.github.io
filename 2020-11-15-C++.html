<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Some notes for C++</title>
<meta name="generator" content="Org mode" />
<meta name="keywords" content="c++" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content">
<h1 class="title">Some notes for C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#compile-and-link">Compile and link</a></li>
<li><a href="#header-and-include">Header and include</a></li>
<li><a href="#default-stuff-in-a-class">Default stuff in a class</a></li>
<li><a href="#when-is-operator-and-when-is-it-ctor.">When is = operator=, and when is it ctor.</a></li>
<li><a href="#static-lifetime-and-access">Static: lifetime and access</a></li>
<li><a href="#virtual-function-and-pure-virtual-function-interface">Virtual function and pure virtual function (interface)</a></li>
<li><a href="#mutable">Mutable</a></li>
<li><a href="#string-literal">String literal</a></li>
<li><a href="#const">Const</a></li>
<li><a href="#stack-vs.-heap-instantiation">Stack vs. heap instantiation</a></li>
<li><a href="#implicit-conversion">Implicit conversion</a></li>
<li><a href="#stdmove">std::move</a></li>
<li><a href="#dont-return-an-rvalue-ref-just-return-a-value">Don't return an rvalue ref, just return a value</a></li>
<li><a href="#stdforward">std::forward</a></li>
<li><a href="#stdunique_ptr-stdshared_ptr-and-stdweak_ptr"><code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code></a></li>
<li><a href="#orgc3e7719">Ownership: pointer, reference, smart pointers</a></li>
<li><a href="#function-pointer">Function pointer</a></li>
<li><a href="#union-and-type-punning">Union and type punning</a></li>
<li><a href="#stdvariant">std::variant</a></li>
<li><a href="#singleton">Singleton</a></li>
<li><a href="#org57567fe">C++14 feels like a patch for C++11</a></li>
<li><a href="#org79365c7">C++17</a></li>
<li><a href="#org913d509">C++20</a>
<ul>
<li><a href="#orgff0ead1">Coroutine</a></li>
<li><a href="#orgcf27692">Concept</a></li>
<li><a href="#org078a1c9">Range</a></li>
<li><a href="#org0d4745c">Module</a></li>
</ul>
</li>
<li><a href="#orgc057208">Design Class</a>
<ul>
<li><a href="#org641f9c8">Don't make data member const or references</a></li>
<li><a href="#orgc16c6e6">Value initializer</a></li>
</ul>
</li>
<li><a href="#org699dae2">RAII: Resource Acquisition is Initialization: it means to cleanup in the destructor.</a>
<ul>
<li><a href="#orgf20af6f">This applies to raw heap pointers, file handles, mutex, etc.</a></li>
<li><a href="#org17d451a">The Rule of Three: all three need to be user defined if RAII.</a>
<ul>
<li><a href="#org209615c">destructor</a></li>
<li><a href="#org00dd904">copy ctor</a></li>
<li><a href="#orgbdddd42">copy assignment: use copy-and-swap to implement it.</a></li>
</ul>
</li>
<li><a href="#org8c794c4">Destroctor is called even after throw</a></li>
<li><a href="#orgf71c96a">The Rule of Three: if not RAII (don't store data or contains only well written Rule of Three classes)</a></li>
<li><a href="#orgce5d98c">The Rule of Five:</a>
<ul>
<li><a href="#org412c60b">all three rules plus</a></li>
<li><a href="#orgf46bf9a">move ctor</a></li>
<li><a href="#org3a10ec2">move assignment</a></li>
</ul>
</li>
<li><a href="#orgb8d90fe">The Rule of Four and a half:</a>
<ul>
<li><a href="#org5dce4dc">All three ctors</a></li>
<li><a href="#orgf961971">merge copy and move assignment into a value assignment</a></li>
<li><a href="#org280a1f5">The half is the swap function.</a></li>
</ul>
</li>
<li><a href="#orge875bb7">Good examples</a>
<ul>
<li><a href="#org0f70044"><code>unique_ptr</code>: ctor, move ctor and move assignment</a></li>
<li><a href="#org6a0e624"><code>shared_ptr</code>: all five</a></li>
<li><a href="#orgd7f0aaf"><code>unique_lock</code></a></li>
<li><a href="#orge1749ab"><code>ifstream</code></a></li>
<li><a href="#orgdabfd67"><code>lock_guard</code>: just ctor and destructor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
These are some notes I wrote as I watched
<a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">Cherno's C++ playlist</a> and some other videos and resources.
</p>

<div id="outline-container-org433a1a4" class="outline-2">
<h2 id="compile-and-link"><a id="org433a1a4"></a>Compile and link</h2>
<div class="outline-text-2" id="text-compile-and-link">
<ul class="org-ul">
<li>When compile a cpp file, all it cares is how the stuff
(functions/class) you use in it is declared. As long as you tell it
the declaration (e.g. function signature), it will compile. Even if it
is never defined.</li>
<li>The linking stage is actually linking all these compile stuff
together. Therefore, if something is not defined, it will have a link
error.</li>
</ul>
</div>
</div>

<div id="outline-container-orgdc78706" class="outline-2">
<h2 id="header-and-include"><a id="orgdc78706"></a>Header and include</h2>
<div class="outline-text-2" id="text-header-and-include">
<ul class="org-ul">
<li><code>#include</code> is just copying all the stuff in the header to the current
file. This also explains why you can do forward declaration.</li>
<li>Headers has the declarations for you to compile the current file
(translation unit).</li>
<li><code>#include &lt;system_header&gt;</code></li>
<li><code>#include "you_own_header"</code></li>
<li>All the C system header ends with .h, e.g., <code>&lt;stdlib.h&gt;</code></li>
<li>All the C++ system header has no file extension, e.g., <code>&lt;iostrem&gt;</code></li>
</ul>
</div>
</div>

<div id="outline-container-org8a2b213" class="outline-2">
<h2 id="default-stuff-in-a-class"><a id="org8a2b213"></a>Default stuff in a class</h2>
<div class="outline-text-2" id="text-default-stuff-in-a-class">
<ul class="org-ul">
<li>There are a default constructor, default destructor, default copy
constructor/assignment operator, and default move
constructor/assignment operator.</li>
<li>default constructor/destructor is as if you have an empty body of the
constructor/destructor. The default constructor will not initialize
the primitive type member variable in your class.</li>
<li>default copy/move ctor do something with <code>std::memcopy</code> and
<code>std::memmove</code>. Therefore, if you have pointers in your class, the
default copy constructor will be a shallow copy.</li>
</ul>
</div>
</div>

<div id="outline-container-org02f2d4f" class="outline-2">
<h2 id="when-is-operator-and-when-is-it-ctor."><a id="org02f2d4f"></a>When is = operator=, and when is it ctor.</h2>
<div class="outline-text-2" id="text-when-is-operator-and-when-is-it-ctor.">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">a</span>;
<span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">b</span> = a; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Constructor</span>
b = a; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">operator=</span>
</pre>
</div>

<p>
The reasoning is pretty simple. The later one is equivalent to
</p>

<div class="org-src-container">
<pre class="src src-c++">b.<span style="font-weight: bold;">operator</span>=(a);
</pre>
</div>

<p>
While in the former one, b has not been constructed yet, so it must be a
constructor.
</p>
</div>
</div>

<div id="outline-container-orgdefae20" class="outline-2">
<h2 id="static-lifetime-and-access"><a id="orgdefae20"></a>Static: lifetime and access</h2>
<div class="outline-text-2" id="text-static-lifetime-and-access">
<ul class="org-ul">
<li>The static keyword inside a local scope, e.g. in a class, function
means

<ul class="org-ul">
<li>The lifetime of this variable is the same as the entire program.</li>
<li>There is only one copy of this variable function.</li>
<li>but only code inside the scope can access it (unless you pass it
out).</li>
<li>static functions is the same as static variables, but they feels a
little bit different

<ul class="org-ul">
<li>forever lifetime: it can be called without an instance.</li>
<li>Only one copy: the static member function does not have a <code>this</code>
inside it.</li>
<li>local access: you need to call it through the class.</li>
</ul></li>
</ul></li>

<li>The static keyword outside a scope just means it is only accessible /
linked within this file/translation unit.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc671bd0" class="outline-2">
<h2 id="virtual-function-and-pure-virtual-function-interface"><a id="orgc671bd0"></a>Virtual function and pure virtual function (interface)</h2>
<div class="outline-text-2" id="text-virtual-function-and-pure-virtual-function-interface">
<ul class="org-ul">
<li>All method functions can be overwritten in the derived class. However,
virtual functions will ask the compiler to create a virtual table in
the runtime. And when you do polymorphism, it knows the correct
function to call. Otherwise it will call the base class method if it
is a base class pointer.</li>
<li>And additional thing pure virtual functions has is that it forces the
derived class to define it.</li>
</ul>
</div>
</div>

<div id="outline-container-org31adc93" class="outline-2">
<h2 id="mutable"><a id="org31adc93"></a>Mutable</h2>
<div class="outline-text-2" id="text-mutable">
<p>
Mark a class variable mutable will allow const methods to change it.
</p>
</div>
</div>

<div id="outline-container-org7745e4f" class="outline-2">
<h2 id="string-literal"><a id="org7745e4f"></a>String literal</h2>
<div class="outline-text-2" id="text-string-literal">
<ul class="org-ul">
<li>They are on a read-only memory, so you cannot modify it.</li>
<li>In order to modify it, you actually ask the compiler to copy it to a
modifiable piece of memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">char</span> * <span style="font-weight: bold; font-style: italic;">a</span> = <span style="font-style: italic;">"hello"</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">convert a const char * const to char *</span>
a[2] = <span style="font-style: italic;">'c'</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Wrong. it is read only.</span>
<span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">b</span>[] = <span style="font-style: italic;">"hello"</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copied from a read only memory to stack.</span>
b[2] = <span style="font-style: italic;">'c'</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">It is okay.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga318f83" class="outline-2">
<h2 id="const"><a id="orga318f83"></a>Const</h2>
<div class="outline-text-2" id="text-const">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> *<span style="font-weight: bold; font-style: italic;">a</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the integer cannot be modified.</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">const</span> * <span style="font-weight: bold; font-style: italic;">b</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">same as above.</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> * <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">c</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the pointer cannot be modified to point to other stuff. BTW, int&amp; is sort of like this. Once it is initialized, it cannot be used to reference a different thing.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org05ddbde" class="outline-2">
<h2 id="stack-vs.-heap-instantiation"><a id="org05ddbde"></a>Stack vs. heap instantiation</h2>
<div class="outline-text-2" id="text-stack-vs.-heap-instantiation">
<ul class="org-ul">
<li>Stack is about 2Mb</li>
<li>Two reasons to do heap instantiation:

<ul class="org-ul">
<li>pass it out of the scope</li>
<li>too big for stack</li>
</ul></li>

<li>Why is it called stack and heap memory:

<ul class="org-ul">
<li>When using stack memory, the variables are created and deleted based
on scope. It works exactly like a stack data structure. When you
create variables in scope, you allocate memory one after another
just like you push things into a stack. When you go out of the
scope, the memory allocated in the code is released one after
another just like you pop things out of a stack.</li>
<li>Stack is a small piece of memory reserved for your program. Heap is
a large piece of memory shared by all other programs. Therefore,
Heap may not be all available for you to use. And the way to manage
which part is available and how much is available is just like a
heap data structure.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org54bba5b" class="outline-2">
<h2 id="implicit-conversion"><a id="org54bba5b"></a>Implicit conversion</h2>
<div class="outline-text-2" id="text-implicit-conversion">
<p>
It only does it once. For example,
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">A</span>
{
    <span style="font-weight: bold;">A</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">a</span>) {}
};
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">print</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">A</span>&amp; <span style="font-weight: bold; font-style: italic;">a</span>)
{
};
print(<span style="font-style: italic;">"hello"</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This will not compile. "hello" is const char* const. It can be converted to std::string. However, you need to further converted to A, while is the second implicit conversion.</span>
print(<span style="font-weight: bold; text-decoration: underline;">std</span>::string(<span style="font-style: italic;">"hello"</span>)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Good. </span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6909ffb" class="outline-2">
<h2 id="stdmove"><a id="org6909ffb"></a>std::move</h2>
<div class="outline-text-2" id="text-stdmove">
<ul class="org-ul">
<li>It is as simple as converting lvalue to rvalue. The real move (include
cleaning up the source properly) happens in the move ctor or move
assignment. std::move is just to make sure you can match to the
function that actually do the move.</li>
<li>In other words, std::move mark a value as temporary (can be stolen
from). The move ctor or assignment actually steals it.</li>
</ul>
</div>
</div>

<div id="outline-container-org80e4ec9" class="outline-2">
<h2 id="dont-return-an-rvalue-ref-just-return-a-value"><a id="org80e4ec9"></a>Don't return an rvalue ref, just return a value</h2>
<div class="outline-text-2" id="text-dont-return-an-rvalue-ref-just-return-a-value">
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">B</span>
{
    <span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">a</span>;
    <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold;">give</span>() {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::move(a); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">what happens here is that, a is moved to a temporary var and this temporary var is returned. </span>
    }
}
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold; text-decoration: underline;">B</span> <span style="font-weight: bold; font-style: italic;">b</span>;
    <span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">a</span> = b.give(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">with copy elision, this line does not trigger either copy or move constructor.</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">B</span>
{
    <span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">a</span>;
    <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold; text-decoration: underline;">A</span>&amp;&amp; <span style="font-weight: bold;">give</span>() {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::move(a); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">what happens here is that, a is convert to a rvalue.</span>
    }
}
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
    <span style="font-weight: bold; text-decoration: underline;">B</span> <span style="font-weight: bold; font-style: italic;">b</span>;
    <span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">a</span> = b.give(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">move constructor is called here.</span>
}
</pre>
</div>

<p>
Therefore, with copy elision, return an <code>A&amp;&amp;</code> does not save you
anything. However, if you return a <code>A&amp;&amp;</code>, potentially it can be misused.
If the receiver uses an <code>A&amp;&amp;</code> to receive it. This will not trigger any
real move, either. If at this moment the original copy is destroyed,
then the receiver end has a dangling pointer.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">A</span>&amp;&amp; <span style="font-weight: bold; font-style: italic;">a</span> = b.give(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">nothing happens here as well.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org17a7d0a" class="outline-2">
<h2 id="stdforward"><a id="org17a7d0a"></a>std::forward</h2>
<div class="outline-text-2" id="text-stdforward">
<p>
It is converting something to T&amp;&amp;. This is only used in a template
function used for relay purposes.
</p>
</div>
</div>

<div id="outline-container-org3e062a8" class="outline-2">
<h2 id="stdunique_ptr-stdshared_ptr-and-stdweak_ptr"><a id="org3e062a8"></a><code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code></h2>
<div class="outline-text-2" id="text-stdunique_ptr-stdshared_ptr-and-stdweak_ptr">
<ul class="org-ul">
<li><code>std::unique_ptr</code> has almost no overhead.</li>
<li><code>std::make_unique</code> is preferred because it handles exception</li>
<li><code>std::shared_ptr</code> is implemented as reference count.</li>
<li><code>std::make_shared</code> is preferred because it initialize control block
and the object together.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc3e7719" class="outline-2">
<h2 id="orgc3e7719">Ownership: pointer, reference, smart pointers</h2>
<div class="outline-text-2" id="text-orgc3e7719">
<p>
What does it mean when passing pointer, reference, smart pointers to a function (ctor).
</p>
<ul class="org-ul">
<li><code>A&amp;</code> is almost the same as <code>A * const</code>, except that reference guarantees its existence, while pointer can be <code>nullptr</code>.</li>
<li>In modern C++ and user side of the code, passing raw pointer and reference means borrow. No need to destroy.
<ul class="org-ul">
<li>There are exceptions in old-style code base, such as ceres-solver, if I remember correctly.</li>
</ul></li>
<li>Pass a <code>unque_ptr</code> is transfering ownership, while <code>shared_ptr</code> is shared ownership.</li>
</ul>
</div>
</div>

<div id="outline-container-org902af4c" class="outline-2">
<h2 id="function-pointer"><a id="org902af4c"></a>Function pointer</h2>
<div class="outline-text-2" id="text-function-pointer">
<ul class="org-ul">
<li>C style function pointer

<ul class="org-ul">
<li><code>ReturnType(*function_pointer)(ArgumentType)</code> this is the
declaration of a function pointer. <code>type variable</code> this is the
declaration of a variable</li>
<li><code>typedef ReturnType(*FunctionPointerType)(ArgumentType)</code> this is how
to typedef a function pointer type. <code>typedef Type NewTypeName</code> is
this a normal typedef.</li>
</ul></li>

<li>lambda function's type is undefined in the standard, so it is up to
the compiler's implementation. That is why you cannot pass it to a C
style function pointer. You can either use a template to hold it, or
convert it to <code>std::function</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org9ad89da" class="outline-2">
<h2 id="union-and-type-punning"><a id="org9ad89da"></a>Union and type punning</h2>
<div class="outline-text-2" id="text-union-and-type-punning">
<ul class="org-ul">
<li>type punning is to interpret a piece of memory as a different type.
For example</li>
</ul>

<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">A</span>
{
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">y</span>;
};
<span style="font-weight: bold; text-decoration: underline;">A</span> <span style="font-weight: bold; font-style: italic;">a</span>;
<span style="font-weight: bold; text-decoration: underline;">int</span>* <span style="font-weight: bold; font-style: italic;">b</span> = (<span style="font-weight: bold; text-decoration: underline;">int</span>*)&amp;a;
b[0]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a.x;</span>
b[1]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a.y;</span>
</pre>
</div>

<ul class="org-ul">
<li>Union is a nicer way to achieve this.</li>
</ul>
</div>
</div>

<div id="outline-container-org930c551" class="outline-2">
<h2 id="stdvariant"><a id="org930c551"></a>std::variant</h2>
<div class="outline-text-2" id="text-stdvariant">
<ul class="org-ul">
<li>a safer way to do Union</li>
<li>but instead of occupying memory that is the max of all the variants
like union, it occupies memory that is the sum of all its variants.</li>
</ul>
</div>
</div>

<div id="outline-container-org46bde8e" class="outline-2">
<h2 id="singleton"><a id="org46bde8e"></a>Singleton</h2>
<div class="outline-text-2" id="text-singleton">
<ul class="org-ul">
<li>a static member function defines and then returns a static variable
looks better than declaring a static variable and then defining this
variable.</li>
</ul>
</div>
</div>

<div id="outline-container-org57567fe" class="outline-2">
<h2 id="org57567fe"><a href="https://www.youtube.com/watch?v=mXxNvaEdNHI">C++14</a> feels like a patch for C++11</h2>
<div class="outline-text-2" id="text-org57567fe">
<ul class="org-ul">
<li><code>auto</code> as a function return type;</li>
<li>Template lambda function using auto keyword</li>
<li><p>
Generalized capture expression in lambda
</p>
<div class="org-src-container">
<pre class="src src-c++">[<span style="font-weight: bold; font-style: italic;">value</span> = v] () {}
</pre>
</div></li>
<li><code>make_unique</code>
Now, technically, you no longer to use explicit <code>new</code> and <code>delete</code>.</li>
<li>More flexible <code>constexpr</code></li>
</ul>
</div>
</div>

<div id="outline-container-org79365c7" class="outline-2">
<h2 id="org79365c7"><a href="https://www.youtube.com/watch?v=QpFjOlzg1r4">C++17</a></h2>
<div class="outline-text-2" id="text-org79365c7">
<ul class="org-ul">
<li><p>
Guaranteed Copy/ Move Elision
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">auto</span> <span style="font-weight: bold;">factory</span>(){
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::make_unique&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;();
  }
<span style="font-weight: bold;">main</span>() {
  <span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">widget</span> = factory(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">move will not be invoked here.</span>
  }
</pre>
</div></li>
<li>more <code>const_expr</code> in std</li>
<li><code>constexpr</code> in lambda</li>
<li><code>std::string_view</code></li>
<li><p>
Class template argument deduction
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">array</span> <span style="font-weight: bold; font-style: italic;">data</span>{1,2,3,4}; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">data will be std::array&lt;int,4&gt;</span>
</pre>
</div></li>
<li>fold expressions in variadic template</li>
<li><p>
structured bindings
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">double</span>&gt; <span style="font-weight: bold; font-style: italic;">v</span>{1,3.};
<span style="font-weight: bold;">auto</span> [first, second] = v;
</pre>
</div></li>
<li><p>
if-init
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">auto</span> <span style="font-weight: bold; font-style: italic;">f</span> = function(); f &gt; 5){
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do something</span>
  }
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org913d509" class="outline-2">
<h2 id="org913d509"><a href="https://www.youtube.com/watch?v=D81yl6_kHEM">C++20</a></h2>
<div class="outline-text-2" id="text-org913d509">
</div>
<div id="outline-container-orgff0ead1" class="outline-3">
<h3 id="orgff0ead1">Coroutine</h3>
<div class="outline-text-3" id="text-orgff0ead1">
<ul class="org-ul">
<li><code>co_yield</code> similar to python's <code>yield</code>
<b>It will be more complete in c++23. Don't do it yourself, use a library for now</b>.
The idea is that the function contains the status, and it returns different value based on the status.
Before <code>co_yield</code>, you can do it in three ways:
<ul class="org-ul">
<li>Create a class that holds the state</li>
<li>Put the state as a global variable and use it in the function. BAD STYLE!</li>
<li>Put the state in the capture of lambda. The real implementation is similar to this. It is like an object without a class definition.</li>
</ul></li>
<li><code>co_wait</code> wait for another thread to <code>co_yield</code>
Before <code>co_wait</code>, you can do it through callback:
<ul class="org-ul">
<li>When wait, register a callback to the other thread</li>
<li>When the other thread yield, call the callback</li>
<li>This is much harder to read.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgcf27692" class="outline-3">
<h3 id="orgcf27692">Concept</h3>
<div class="outline-text-3" id="text-orgcf27692">
<ul class="org-ul">
<li><p>
For template, explicitly write out the constraint of the template type.
Before C++20, template type can be anything, compile will output a "wired" error when you use the template function with a not supported type.
The way to constraint the template type is through <code>enable_if</code>, but it is pretty hard to write.
</p>

<p>
Another alternative is to use interface class and polymorphism, but this is more for unpredictable runtime types.
It is over kill and has extra price to pay if your type is known at compile-time.
</p></li>
<li>Can be combined.</li>
</ul>
</div>
</div>

<div id="outline-container-org078a1c9" class="outline-3">
<h3 id="org078a1c9">Range</h3>
<div class="outline-text-3" id="text-org078a1c9">
<ul class="org-ul">
<li>Build on top of concept</li>
<li>Lazy evaluation</li>
</ul>
</div>
</div>

<div id="outline-container-org0d4745c" class="outline-3">
<h3 id="org0d4745c">Module</h3>
<div class="outline-text-3" id="text-org0d4745c">
<ul class="org-ul">
<li>*.cppm</li>
<li>export</li>
<li>import</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc057208" class="outline-2">
<h2 id="orgc057208"><a href="https://www.youtube.com/watch?v=O65lEiYkkbc">Design Class</a></h2>
<div class="outline-text-2" id="text-orgc057208">
</div>
<div id="outline-container-org641f9c8" class="outline-3">
<h3 id="org641f9c8">Don't make data member const or references</h3>
<div class="outline-text-3" id="text-org641f9c8">
<ul class="org-ul">
<li>Otherwise, the copy assignment and move ctor/assignment will be gone. but copy ctor is okay.</li>
<li>use a raw pointer instead of a reference. Function interface can still be a reference. It is just stored as a pointer.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc16c6e6" class="outline-3">
<h3 id="orgc16c6e6">Value initializer</h3>
<div class="outline-text-3" id="text-orgc16c6e6">
<ul class="org-ul">
<li><code>Widget w{};</code> will also initialize <code>int</code> or <code>int*</code>.</li>
<li>best practice is to put the initial value in the class when you declare the variable. The reason to not put in ctor, is to reduce duplication if you have two ctors that both need to initialize.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org699dae2" class="outline-2">
<h2 id="org699dae2"><a href="https://www.youtube.com/watch?v=7Qgd9B1KuMQ">RAII: Resource Acquisition is Initialization: it means to cleanup in the destructor.</a></h2>
<div class="outline-text-2" id="text-org699dae2">
</div>
<div id="outline-container-orgf20af6f" class="outline-3">
<h3 id="orgf20af6f">This applies to raw heap pointers, file handles, mutex, etc.</h3>
</div>
<div id="outline-container-org17d451a" class="outline-3">
<h3 id="org17d451a">The Rule of Three: all three need to be user defined if RAII.</h3>
<div class="outline-text-3" id="text-org17d451a">
</div>
<div id="outline-container-org209615c" class="outline-4">
<h4 id="org209615c">destructor</h4>
</div>
<div id="outline-container-org00dd904" class="outline-4">
<h4 id="org00dd904">copy ctor</h4>
<div class="outline-text-4" id="text-org00dd904">
<p>
The default will lead to double deletion
</p>
</div>
</div>
<div id="outline-container-orgbdddd42" class="outline-4">
<h4 id="orgbdddd42">copy assignment: use copy-and-swap to implement it.</h4>
<div class="outline-text-4" id="text-orgbdddd42">
<ul class="org-ul">
<li>copy: call copy ctor and generate a new object</li>
<li>swap: swap LHS and the new object and use the new objects' destructor to free the LHS.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8c794c4" class="outline-3">
<h3 id="org8c794c4">Destroctor is called even after throw</h3>
</div>
<div id="outline-container-orgf71c96a" class="outline-3">
<h3 id="orgf71c96a">The Rule of Three: if not RAII (don't store data or contains only well written Rule of Three classes)</h3>
<div class="outline-text-3" id="text-orgf71c96a">
<p>
Let compiler generate them.
</p>
</div>
</div>
<div id="outline-container-orgce5d98c" class="outline-3">
<h3 id="orgce5d98c">The Rule of Five:</h3>
<div class="outline-text-3" id="text-orgce5d98c">
</div>
<div id="outline-container-org412c60b" class="outline-4">
<h4 id="org412c60b">all three rules plus</h4>
</div>
<div id="outline-container-orgf46bf9a" class="outline-4">
<h4 id="orgf46bf9a">move ctor</h4>
<div class="outline-text-4" id="text-orgf46bf9a">
<p>
Destroy RHS
</p>
</div>
</div>
<div id="outline-container-org3a10ec2" class="outline-4">
<h4 id="org3a10ec2">move assignment</h4>
<div class="outline-text-4" id="text-org3a10ec2">
<ul class="org-ul">
<li>move: call move ctor: RHS is destroyed.</li>
<li>swap: same as before, use the destructor of the new object to free LHS.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb8d90fe" class="outline-3">
<h3 id="orgb8d90fe">The Rule of Four and a half:</h3>
<div class="outline-text-3" id="text-orgb8d90fe">
</div>
<div id="outline-container-org5dce4dc" class="outline-4">
<h4 id="org5dce4dc">All three ctors</h4>
</div>
<div id="outline-container-orgf961971" class="outline-4">
<h4 id="orgf961971">merge copy and move assignment into a value assignment</h4>
<div class="outline-text-4" id="text-orgf961971">
<p>
since the first thing of these two are creating a copy (through copy or move ctor) anyway
</p>
</div>
</div>
<div id="outline-container-org280a1f5" class="outline-4">
<h4 id="org280a1f5">The half is the swap function.</h4>
<div class="outline-text-4" id="text-org280a1f5">
<p>
Otherwise, the default swap will call move and copy.
</p>
</div>
</div>
</div>
<div id="outline-container-orge875bb7" class="outline-3">
<h3 id="orge875bb7">Good examples</h3>
<div class="outline-text-3" id="text-orge875bb7">
</div>
<div id="outline-container-org0f70044" class="outline-4">
<h4 id="org0f70044"><code>unique_ptr</code>: ctor, move ctor and move assignment</h4>
</div>
<div id="outline-container-org6a0e624" class="outline-4">
<h4 id="org6a0e624"><code>shared_ptr</code>: all five</h4>
</div>
<div id="outline-container-orgd7f0aaf" class="outline-4">
<h4 id="orgd7f0aaf"><code>unique_lock</code></h4>
</div>
<div id="outline-container-orge1749ab" class="outline-4">
<h4 id="orge1749ab"><code>ifstream</code></h4>
</div>
<div id="outline-container-orgdabfd67" class="outline-4">
<h4 id="orgdabfd67"><code>lock_guard</code>: just ctor and destructor</h4>
<div class="outline-text-4" id="text-orgdabfd67">
<script src="https://utteranc.es/client.js"
        repo="sychen52/sychen52.github.io"
        issue-term="pathname"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-11-15 Sun 00:00</p>
<p class="validation"></p>
</div>
</body>
</html>
