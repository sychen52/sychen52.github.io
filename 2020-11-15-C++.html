<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga5a831b">When compile a cpp file, all it cares is how the stuff (functions/class) you use in it is declared. As long as you tell it the declaration (e.g. function signature), it will compile. Even if it is never defined.</a></li>
<li><a href="#orgc672c0b">The linking stage is actually linking all these compile stuff together. Therefore, if something is not defined, it will have a link error.</a></li>
<li><a href="#org5a420b8">`#include` is just copying all the stuff in the header to the current file. This also explains why you can do forward declaration.</a></li>
<li><a href="#org7965e27">Headers has the declarations for you to compile the current file (translation unit).</a></li>
<li><a href="#org3724d54">`#include &lt;system<sub>header</sub>&gt;`</a></li>
<li><a href="#org73a32c8">`#include "you<sub>own</sub><sub>header</sub>"`</a></li>
<li><a href="#org8d9ae30">All the C system header ends with .h, e.g., `&lt;stdlib.h&gt;`</a></li>
<li><a href="#org0bed404">All the C++ system header has no file extension, e.g., `&lt;iostrem&gt;`</a></li>
<li><a href="#org1b6b131">There are a default constructor, default destructor, default copy constructor/assignment operator, and default move constructor/assignment operator.</a></li>
<li><a href="#org0c403c5">default constructor/destructor is as if you have an empty body of the constructor/destructor. The default constructor will not initialize the primitive type member variable in your class.</a></li>
<li><a href="#orgf81d6af">default copy/move ctor do something with `std::memcopy` and `std::memmove`. Therefore, if you have pointers in your class, the default copy constructor will be a shallow copy.</a></li>
<li><a href="#orgaf3111e">The static keyword inside a local scope, e.g. in a class, function means</a></li>
<li><a href="#org96fef63">The static keyword outside a scope just means it is only accessible / linked within this file/translation unit.</a></li>
<li><a href="#orgfd7d531">All method functions can be overwritten in the derived class. However, virtual functions will ask the compiler to create a virtual table in the runtime. And when you do polymorphism, it knows the correct function to call. Otherwise it will call the base class method if it is a base class pointer.</a></li>
<li><a href="#org68975a9">And additional thing pure virtual functions has is that it forces the derived class to define it.</a></li>
<li><a href="#org7e4f731">They are on a read-only memory, so you cannot modify it.</a></li>
<li><a href="#orgd5d41ad">In order to modify it, you actually ask the compiler to copy it to a modifiable piece of memory.</a></li>
<li><a href="#org406b2b3">Stack is about 2Mb</a></li>
<li><a href="#org3e2b865">Two reasons to do heap instantiation:</a></li>
<li><a href="#org3ad4489">Why is it called stack and heap memory:</a></li>
<li><a href="#org1b76156">It is as simple as converting lvalue to rvalue. The real move (include cleaning up the source properly) happens in the move ctor or move assignment. std::move is just to make sure you can match to the function that actually do the move.</a></li>
<li><a href="#orge6274b8">In other words, std::move mark a value as temporary (can be stolen from). The move ctor or assignment actually steals it.</a></li>
<li><a href="#org423561c">`std::unique<sub>ptr</sub>` has almost no overhead.</a></li>
<li><a href="#org60d7598">`std::make<sub>unique</sub>` is preferred because it handles exception</a></li>
<li><a href="#org471af3c">`std::shared<sub>ptr</sub>` is implemented as reference count.</a></li>
<li><a href="#orge43cf73">`std::make<sub>shared</sub>` is preferred because it initialize control block and the object together.</a></li>
<li><a href="#orgb078a5f">C style function pointer</a></li>
<li><a href="#orga14a120">lambda function's type is undefined in the standard, so it is up to the compiler's implementation. That is why you cannot pass it to a C style function pointer. You can either use a template to hold it, or convert it to `std::function`.</a></li>
<li><a href="#org781a34f">type punning is to interpret a piece of memory as a different type. For example</a></li>
<li><a href="#org05df7d9">Union is a nicer way to achieve this.</a></li>
<li><a href="#org024b363">a safer way to do Union</a></li>
<li><a href="#org1abcb60">but instead of occupying memory that is the max of all the variants like union, it occupies memory that is the sum of all its variants.</a></li>
<li><a href="#org8fbbb5f">a static member function defines and then returns a static variable looks better than declaring a static variable and then defining this variable.</a></li>
</ul>
</div>
</div>
<p>
&#x2014;
layout: post
title:  "Some notes for C++"
date:   2020-11-15 17:28:18 -0800
categories: []
&#x2014;
These are some notes I wrote as I watched [Cherno's C++ playlist](<a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb</a>).
</p>
<div id="outline-container-orga5a831b" class="outline-2">
<h2 id="orga5a831b">When compile a cpp file, all it cares is how the stuff (functions/class) you use in it is declared. As long as you tell it the declaration (e.g. function signature), it will compile. Even if it is never defined.</h2>
</div>
<div id="outline-container-orgc672c0b" class="outline-2">
<h2 id="orgc672c0b">The linking stage is actually linking all these compile stuff together. Therefore, if something is not defined, it will have a link error.</h2>
<div class="outline-text-2" id="text-orgc672c0b">
</div>
</div>
<div id="outline-container-org5a420b8" class="outline-2">
<h2 id="org5a420b8">`#include` is just copying all the stuff in the header to the current file. This also explains why you can do forward declaration.</h2>
</div>
<div id="outline-container-org7965e27" class="outline-2">
<h2 id="org7965e27">Headers has the declarations for you to compile the current file (translation unit).</h2>
</div>
<div id="outline-container-org3724d54" class="outline-2">
<h2 id="org3724d54">`#include &lt;system<sub>header</sub>&gt;`</h2>
</div>
<div id="outline-container-org73a32c8" class="outline-2">
<h2 id="org73a32c8">`#include "you<sub>own</sub><sub>header</sub>"`</h2>
</div>
<div id="outline-container-org8d9ae30" class="outline-2">
<h2 id="org8d9ae30">All the C system header ends with .h, e.g., `&lt;stdlib.h&gt;`</h2>
</div>
<div id="outline-container-org0bed404" class="outline-2">
<h2 id="org0bed404">All the C++ system header has no file extension, e.g., `&lt;iostrem&gt;`</h2>
<div class="outline-text-2" id="text-org0bed404">
</div>
</div>
<div id="outline-container-org1b6b131" class="outline-2">
<h2 id="org1b6b131">There are a default constructor, default destructor, default copy constructor/assignment operator, and default move constructor/assignment operator.</h2>
</div>
<div id="outline-container-org0c403c5" class="outline-2">
<h2 id="org0c403c5">default constructor/destructor is as if you have an empty body of the constructor/destructor. The default constructor will not initialize the primitive type member variable in your class.</h2>
</div>
<div id="outline-container-orgf81d6af" class="outline-2">
<h2 id="orgf81d6af">default copy/move ctor do something with `std::memcopy` and `std::memmove`. Therefore, if you have pointers in your class, the default copy constructor will be a shallow copy.</h2>
<div class="outline-text-2" id="text-orgf81d6af">
<p>
```
A a;
A b = a; <i>/ Constructor
b = a; /</i> operator=
```
The reasoning is pretty simple. The later one is equivalent to
```
b.operator=(a);
```
While in the former one, b has not been constructed yet, so it must be a constructor.
</p>
</div>
</div>
<div id="outline-container-orgaf3111e" class="outline-2">
<h2 id="orgaf3111e">The static keyword inside a local scope, e.g. in a class, function means</h2>
<div class="outline-text-2" id="text-orgaf3111e">
<ul class="org-ul">
<li>The lifetime of this variable is the same as the entire program.</li>
<li>There is only one copy of this variable function.</li>
<li>but only code inside the scope can access it (unless you pass it out).</li>
<li>static functions is the same as static variables, but they feels a little bit different
<ul class="org-ul">
<li>forever lifetime: it can be called without an instance.</li>
<li>Only one copy: the static member function does not have a `this` inside it.</li>
<li>local access: you need to call it through the class.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org96fef63" class="outline-2">
<h2 id="org96fef63">The static keyword outside a scope just means it is only accessible / linked within this file/translation unit.</h2>
<div class="outline-text-2" id="text-org96fef63">
</div>
</div>
<div id="outline-container-orgfd7d531" class="outline-2">
<h2 id="orgfd7d531">All method functions can be overwritten in the derived class. However, virtual functions will ask the compiler to create a virtual table in the runtime. And when you do polymorphism, it knows the correct function to call. Otherwise it will call the base class method if it is a base class pointer.</h2>
</div>
<div id="outline-container-org68975a9" class="outline-2">
<h2 id="org68975a9">And additional thing pure virtual functions has is that it forces the derived class to define it.</h2>
<div class="outline-text-2" id="text-org68975a9">
<p>
Mark a class variable mutable will allow const methods to change it.
</p>
</div>
</div>
<div id="outline-container-org7e4f731" class="outline-2">
<h2 id="org7e4f731">They are on a read-only memory, so you cannot modify it.</h2>
</div>
<div id="outline-container-orgd5d41ad" class="outline-2">
<h2 id="orgd5d41ad">In order to modify it, you actually ask the compiler to copy it to a modifiable piece of memory.</h2>
<div class="outline-text-2" id="text-orgd5d41ad">
<p>
```
char * a = "hello"; <i>/ convert a const char * const to char *
a[2] = 'c'; /</i> Wrong. it is read only.
char b[] = "hello"; <i>/ copied from a read only memory to stack.
b[2] = 'c'; /</i> It is okay.
```
</p>

<p>
```
const int *a; <i>/ the integer cannot be modified.
int const * b; /</i> same as above.
int * const c; // the pointer cannot be modified to point to other stuff. BTW, int&amp; is sort of like this. Once it is initialized, it cannot be used to reference a different thing.
```
</p>
</div>
</div>
<div id="outline-container-org406b2b3" class="outline-2">
<h2 id="org406b2b3">Stack is about 2Mb</h2>
</div>
<div id="outline-container-org3e2b865" class="outline-2">
<h2 id="org3e2b865">Two reasons to do heap instantiation:</h2>
<div class="outline-text-2" id="text-org3e2b865">
<ul class="org-ul">
<li>pass it out of the scope</li>
<li>too big for stack</li>
</ul>
</div>
</div>
<div id="outline-container-org3ad4489" class="outline-2">
<h2 id="org3ad4489">Why is it called stack and heap memory:</h2>
<div class="outline-text-2" id="text-org3ad4489">
<ul class="org-ul">
<li>When using stack memory, the variables are created and deleted based on scope. It works exactly like a stack data structure. When you create variables in scope, you allocate memory one after another just like you push things into a stack. When you go out of the scope, the memory allocated in the code is released one after another just like you pop things out of a stack.</li>
<li>Stack is a small piece of memory reserved for your program. Heap is a large piece of memory shared by all other programs. Therefore, Heap may not be all available for you to use. And the way to manage which part is available and how much is available is just like a heap data structure.</li>
</ul>

<p>
It only does it once. For example,
```
class A
{
    A (std::string a) {}
};
void print(const A&amp; a)
{
};
print("hello"); <i>/ This will not compile. "hello" is const char* const. It can be converted to std::string. However, you need to further converted to A, while is the second implicit conversion.
print(std::string("hello")); /</i> Good. 
```
</p>
</div>
</div>
<div id="outline-container-org1b76156" class="outline-2">
<h2 id="org1b76156">It is as simple as converting lvalue to rvalue. The real move (include cleaning up the source properly) happens in the move ctor or move assignment. std::move is just to make sure you can match to the function that actually do the move.</h2>
</div>
<div id="outline-container-orge6274b8" class="outline-2">
<h2 id="orge6274b8">In other words, std::move mark a value as temporary (can be stolen from). The move ctor or assignment actually steals it.</h2>
<div class="outline-text-2" id="text-orge6274b8">
<p>
```
class B
{
    A a;
    public:
    A give() {
        return std::move(a); // what happens here is that, a is moved to a temporary var and this temporary var is returned. 
    }
}
int main() {
    B b;
    A a = b.give(); // with copy elision, this line does not trigger either copy or move constructor.
}
```
```
class B
{
    A a;
    public:
    A&amp;&amp; give() {
        return std::move(a); // what happens here is that, a is convert to a rvalue.
    }
}
int main() {
    B b;
    A a = b.give(); // move constructor is called here.
}
```
Therefore, with copy elision, return an `A&amp;&amp;` does not save you anything. However, if you return a `A&amp;&amp;`, potentially it can be misused. If the receiver uses an `A&amp;&amp;` to receive it. This will not trigger any real move, either. If at this moment the original copy is destroyed, then the receiver end has a dangling pointer.
```
A&amp;&amp; a = b.give(); // nothing happens here as well.
```
</p>

<p>
It is converting something to T&amp;&amp;. This is only used in a template function used for relay purposes.
</p>
</div>
</div>
<div id="outline-container-org423561c" class="outline-2">
<h2 id="org423561c">`std::unique<sub>ptr</sub>` has almost no overhead.</h2>
</div>
<div id="outline-container-org60d7598" class="outline-2">
<h2 id="org60d7598">`std::make<sub>unique</sub>` is preferred because it handles exception</h2>
</div>
<div id="outline-container-org471af3c" class="outline-2">
<h2 id="org471af3c">`std::shared<sub>ptr</sub>` is implemented as reference count.</h2>
</div>
<div id="outline-container-orge43cf73" class="outline-2">
<h2 id="orge43cf73">`std::make<sub>shared</sub>` is preferred because it initialize control block and the object together.</h2>
<div class="outline-text-2" id="text-orge43cf73">
</div>
</div>
<div id="outline-container-orgb078a5f" class="outline-2">
<h2 id="orgb078a5f">C style function pointer</h2>
<div class="outline-text-2" id="text-orgb078a5f">
<ul class="org-ul">
<li>`ReturnType(*function<sub>pointer</sub>)(ArgumentType)` this is the declaration of a function pointer. `type variable` this is the declaration of a variable</li>
<li>`typedef ReturnType(*FunctionPointerType)(ArgumentType)` this is how to typedef a function pointer type. `typedef Type NewTypeName` is this a normal typedef.</li>
</ul>
</div>
</div>
<div id="outline-container-orga14a120" class="outline-2">
<h2 id="orga14a120">lambda function's type is undefined in the standard, so it is up to the compiler's implementation. That is why you cannot pass it to a C style function pointer. You can either use a template to hold it, or convert it to `std::function`.</h2>
<div class="outline-text-2" id="text-orga14a120">
</div>
</div>
<div id="outline-container-org781a34f" class="outline-2">
<h2 id="org781a34f">type punning is to interpret a piece of memory as a different type. For example</h2>
<div class="outline-text-2" id="text-org781a34f">
<p>
```
struct A
{
    int x, y;
};
A a;
int* b = (int*)&amp;a;
b[0]; <i>/ a.x;
b[1]; /</i> a.y;
```
</p>
</div>
</div>
<div id="outline-container-org05df7d9" class="outline-2">
<h2 id="org05df7d9">Union is a nicer way to achieve this.</h2>
<div class="outline-text-2" id="text-org05df7d9">
</div>
</div>
<div id="outline-container-org024b363" class="outline-2">
<h2 id="org024b363">a safer way to do Union</h2>
</div>
<div id="outline-container-org1abcb60" class="outline-2">
<h2 id="org1abcb60">but instead of occupying memory that is the max of all the variants like union, it occupies memory that is the sum of all its variants.</h2>
<div class="outline-text-2" id="text-org1abcb60">
</div>
</div>
<div id="outline-container-org8fbbb5f" class="outline-2">
<h2 id="org8fbbb5f">a static member function defines and then returns a static variable looks better than declaring a static variable and then defining this variable.</h2>
<div class="outline-text-2" id="text-org8fbbb5f">
<p>
{%- include utterance<sub>comments.html</sub> -%}
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="validation"></p>
</div>
</body>
</html>
