<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Julia Performance Tips</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="https://orgmode.org/worg/style/worg.css"/>
</head>
<body>
<div id="content">
<h1 class="title">Julia Performance Tips</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgee137ab">Global variable</a></li>
<li><a href="#orgb69a884">Type: T &lt;: Union{T, &#x2026;} &lt;: Any</a></li>
<li><a href="#orgcd874fc">Type declaration with abstract type</a>
<ul>
<li><a href="#orgd755a52">It is good for function arguments: reusable for multiple types.</a></li>
<li><a href="#org924e05a">It is bad for fields in a struct</a></li>
</ul>
</li>
<li><a href="#org5a7adc4">Multiple Dispatch</a></li>
<li><a href="#orgd03c9e3">Dict vs. Array</a></li>
<li><a href="#orgfcb8a3e">where</a>
<ul>
<li><a href="#org1cbcc42">parametric type:</a></li>
<li><a href="#org546edcb">method</a></li>
<li><a href="#org4e85fba">struct</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This is a note for  <a href="https://github.com/AdvancedScientificComputingInJuliaWashU/Performance.jl">https://github.com/AdvancedScientificComputingInJuliaWashU/Performance.jl</a>
</p>


<div id="outline-container-orgee137ab" class="outline-2">
<h2 id="orgee137ab">Global variable</h2>
<div class="outline-text-2" id="text-orgee137ab">
<ul class="org-ul">
<li>Avoid if possible</li>
<li>If not, use a const Ref to get the type fixed</li>
</ul>
</div>
</div>

<div id="outline-container-orgb69a884" class="outline-2">
<h2 id="orgb69a884">Type: T &lt;: Union{T, &#x2026;} &lt;: Any</h2>
<div class="outline-text-2" id="text-orgb69a884">
<ul class="org-ul">
<li>If you do not specify a type, it is type Any</li>
<li>A single concrete type is the best</li>
<li>If not possible, a union of all possible types is still <a href="https://julialang.org/blog/2018/08/union-splitting/">way better than Any</a>.</li>
<li>This is especially true if it is in a container such as Array.</li>
</ul>
</div>
</div>

<div id="outline-container-orgcd874fc" class="outline-2">
<h2 id="orgcd874fc">Type declaration with abstract type</h2>
<div class="outline-text-2" id="text-orgcd874fc">
</div>
<div id="outline-container-orgd755a52" class="outline-3">
<h3 id="orgd755a52">It is good for function arguments: reusable for multiple types.</h3>
<div class="outline-text-3" id="text-orgd755a52">
<ul class="org-ul">
<li>For example, <code>function f(a:Real)</code> means when you call it with <code>f(1)</code>, a <code>f(a::Int64)</code> will be generated and compiled.</li>
</ul>
</div>
</div>


<div id="outline-container-org924e05a" class="outline-3">
<h3 id="org924e05a"><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-fields-with-abstract-type">It is bad for fields in a struct</a></h3>
<div class="outline-text-3" id="text-org924e05a">
<ul class="org-ul">
<li><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-fields-with-abstract-type">The compiler uses the types of objects, not their values, to determine how to build code.</a></li>
<li><p>
For the following example, in <code>S{Int64}</code>, and <code>s.a</code> could be <code>Vector{Int64}</code> or <code>SparseVector{Int64}</code>. As a result, a concrete type with an abstract field, e.g. <code>S{Int64}</code>, feels like an abstract type itself. Imagine if you put it into a Vector, <code>Vector{S{Int64}}</code> is like <code>Vector{AbstractVector{Int64}}</code>. The memory layout of each <code>AbstractVector{Int64}</code> can be very different (for example, some are static, some are dynamic.). Therefore, it is hard to optimize.
</p>
<ul class="org-ul">
<li>If it is a mutable struct, you can even change <code>s.a</code>'s type at runtime after creation. Therefore, the compiler has no way to optimize it.</li>
</ul>
<div class="org-src-container">
<pre class="src src-julia">struct S{T}
    a::AbstractVector{T}
end
</pre>
</div></li>
<li><p>
The good version is as follows. In a <code>S{Vector{Int}}</code>, <code>s.a</code> must be <code>Vector{Int}</code>.
</p>
<div class="org-src-container">
<pre class="src src-julia">struct S{T&lt;:AbstractVector}
    a::T
end
</pre>
</div></li>

<li><b>The key is, make sure once the type of S is specified as concrete, all its fields are concrete as well.</b></li>
<li>If you specify a field as an abstract type, the functions applies on it will likely return type: Any (Because anyone can subtype this abstract type and define a method for the function to return whatever type). Functions includes getindex. This meaning array[i] can return type Any, even if array::AbstractVector{Int64}. <b>Although in the runtime, you can see the type being correct. However, @code<sub>warntype</sub> or @inferred cannot infer the type while compiling.</b></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5a7adc4" class="outline-2">
<h2 id="org5a7adc4">Multiple Dispatch</h2>
<div class="outline-text-2" id="text-org5a7adc4">
<ul class="org-ul">
<li>As a rule of thumb, compile time multiple dispatch is as fast as C/C++, Julia can do all the optimizations like inlining. However, runtime multiple dispatch needs to do a lookup and it is slow (can be slower than runtime if-else check)</li>
<li><a href="https://github.com/AdvancedScientificComputingInJuliaWashU/Performance.jl/blob/main/test/type_abuse.jl">"When types can't be predicted in advance, you're better off doing more at runtime and less via the type system.</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd03c9e3" class="outline-2">
<h2 id="orgd03c9e3">Dict vs. Array</h2>
<div class="outline-text-2" id="text-orgd03c9e3">
<ul class="org-ul">
<li>Hash table lookup can be a order of magnitude slower than Array lookup (even with some condiction check)</li>
<li>If you are working with char, using Array as a dictionary.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfcb8a3e" class="outline-2">
<h2 id="orgfcb8a3e">where</h2>
<div class="outline-text-2" id="text-orgfcb8a3e">
</div>
<div id="outline-container-org1cbcc42" class="outline-3">
<h3 id="org1cbcc42">parametric type:</h3>
<div class="outline-text-3" id="text-org1cbcc42">
<ul class="org-ul">
<li><code>Vector{&lt;:Real}</code> or <code>Vector{T} where T &lt;: Real</code> means Union{Vector{T} for all T belong to Real}.</li>
<li>Unionall: <code>Vector</code> means <code>Vector{T} where T &lt;: Any</code></li>
</ul>
</div>
</div>
<div id="outline-container-org546edcb" class="outline-3">
<h3 id="org546edcb">method</h3>
<div class="outline-text-3" id="text-org546edcb">
<ul class="org-ul">
<li><code>function f(x::T) where {T}</code> just tells the parser, T is template/parametric. <code>function f(x::T) where {T&lt;:Real}</code> or <code>function f(x::T where T&lt;:Real)</code> can be used to put some constraint on the type.</li>
</ul>
</div>
</div>
<div id="outline-container-org4e85fba" class="outline-3">
<h3 id="org4e85fba">struct</h3>
<div class="outline-text-3" id="text-org4e85fba">
<ul class="org-ul">
<li>On the other hand, there is no <code>where</code> for struct to put constraints. You directly put constraints in the <code>{}</code>. For example, <code>struct S{T&lt;:Real}</code>.</li>
</ul>

<script src="https://utteranc.es/client.js"
        repo="sychen52/sychen52.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="validation"></p>
</div>
</body>
</html>
