<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org62c4cfc">Assignment, state, and side effects</a>
<ul>
<li><a href="#org1ba20e9">Bound variables (in current scope)</a></li>
<li><a href="#org1399375">Free variables (from the outside of current scope)</a></li>
<li><a href="#org243b7da">Procedure</a></li>
<li><a href="#org186015b">Function</a></li>
<li><a href="#org691c247">Side effects</a></li>
<li><a href="#orgd10048e">Object</a></li>
<li><a href="#org736bfd2">Assignment / Mutation</a></li>
</ul>
</li>
<li><a href="#orgc37a44b">Stream</a>
<ul>
<li><a href="#orgc22ef40">similar to list</a></li>
<li><a href="#orgd1ebfd0">Diff with list</a></li>
</ul>
</li>
<li><a href="#org0c85e2a">Metacircular Evaluator</a></li>
</ul>
</div>
</div>
<div id="outline-container-org62c4cfc" class="outline-2">
<h2 id="org62c4cfc">Assignment, state, and side effects</h2>
<div class="outline-text-2" id="text-org62c4cfc">
</div>
<div id="outline-container-org1ba20e9" class="outline-3">
<h3 id="org1ba20e9">Bound variables (in current scope)</h3>
<div class="outline-text-3" id="text-org1ba20e9">
<p>
The ones in formal parameter list (passed in as arguments).
</p>
</div>
</div>
<div id="outline-container-org1399375" class="outline-3">
<h3 id="org1399375">Free variables (from the outside of current scope)</h3>
<div class="outline-text-3" id="text-org1399375">
<p>
Captured from outside.
Even other functions you call inside a function are free variables.
</p>
</div>
</div>
<div id="outline-container-org243b7da" class="outline-3">
<h3 id="org243b7da">Procedure</h3>
<div class="outline-text-3" id="text-org243b7da">
<ul class="org-ul">
<li>I have an implementation in <a href="https://github.com/sychen52/mal/tree/master/impls/c++">mal</a>.</li>
<li>Environment is a pointer to a chain of frames.</li>
<li>Eval a lambda will return a procedure. The parent environment frame is stored.</li>
<li>Apply a procedure will create a new frame and eval the body of lambda in it.</li>
</ul>
</div>
</div>
<div id="outline-container-org186015b" class="outline-3">
<h3 id="org186015b">Function</h3>
<div class="outline-text-3" id="text-org186015b">
<p>
A procedure is a function, if same input, same output, no internal state change.
</p>
</div>
</div>
<div id="outline-container-org691c247" class="outline-3">
<h3 id="org691c247">Side effects</h3>
<div class="outline-text-3" id="text-org691c247">
<p>
A procedure gives different output even when same input is given, because its internal state changes.
</p>
</div>
</div>
<div id="outline-container-orgd10048e" class="outline-3">
<h3 id="orgd10048e">Object</h3>
<div class="outline-text-3" id="text-orgd10048e">
<ul class="org-ul">
<li>From my OOP perspective, an object is like an instance of a class.</li>
<li>In dynamic language, an object is much more flexible, because you can monkey patch it to add new method or variable to it.</li>
<li>A boarder definition of an object: something with (mutable) states (member variable in OOP) and some actions (member function in OOP) can be applied to it.</li>
<li>In this boarder definition, a procedure is an object.</li>
<li>This is why I feel lambda function in C++ is like a one time class (captures are its member variables passed in from output; the lambda body is the only member function. And this class only instantiates one object and that is this "lambda object").</li>
</ul>
</div>
</div>
<div id="outline-container-org736bfd2" class="outline-3">
<h3 id="org736bfd2">Assignment / Mutation</h3>
<div class="outline-text-3" id="text-org736bfd2">
<ul class="org-ul">
<li>Because of it, we need to have environment (frames) that holds the values, so that you know where to look up and change. Otherwise, we can just use the substitution model. (The substitution model is like the way I implement built-in function in mal, because they don't have a state. While the way I implement fn* (lambda) is the same as this environment frames)</li>
<li>Because of it, we now have identity (of an object) and sharing.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc37a44b" class="outline-2">
<h2 id="orgc37a44b">Stream</h2>
<div class="outline-text-2" id="text-orgc37a44b">
</div>
<div id="outline-container-orgc22ef40" class="outline-3">
<h3 id="orgc22ef40">similar to list</h3>
<div class="outline-text-3" id="text-orgc22ef40">
<ul class="org-ul">
<li>Stream has cons-stream, head, and tail. The tail returns another stream.</li>
<li>Filter, map, reduce can be built with these three functions.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd1ebfd0" class="outline-3">
<h3 id="orgd1ebfd0">Diff with list</h3>
<div class="outline-text-3" id="text-orgd1ebfd0">
<ul class="org-ul">
<li>The computation of each item in stream is lazy. e.g. yield in python.</li>
<li>A stream is a pair, with the head being the current value and the tail being a promise to compute the next value.</li>
<li>A promise is a lambda with no arguments. When applied, it gives the value.</li>
<li>You can even add some cache to this promise so that it only needs to be computed once.
<ul class="org-ul">
<li>In lisp, the way to cache is to use let to create some local variables, then define another lambda function in the let and capture the local state as free variable, inside this lambda, you use this free variable as state.</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0c85e2a" class="outline-2">
<h2 id="org0c85e2a">Metacircular Evaluator</h2>
<div class="outline-text-2" id="text-org0c85e2a">
<ul class="org-ul">
<li>(delay f) is: wrap the function f into a lambda function to not evaluate it.</li>
<li>(force delayedF) is: call the wrapped function by delay</li>
<li>This way, when you pass a delay around, the receiver end needs to know it is a delayed function, and force it.</li>
<li>In order to better isolated modules, and better decouple this sender and receiver ends. i.e. no need to know whether it is a delayed function:
<ul class="org-ul">
<li>A way is to delay everywhere, i.e. the arguments of a function is not evaluated before apply.</li>
<li>Another way is for receiver to take care of both delay and non-delayed function based on some flag that is passed in.</li>
<li>However, for the approach above, you need to do similar things for every function that needs to accept either delay or non-delayed function. A better way is to support it in the language interpreter. I think that is what 7B last 1/3 is about.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="validation"></p>
</div>
</body>
</html>
